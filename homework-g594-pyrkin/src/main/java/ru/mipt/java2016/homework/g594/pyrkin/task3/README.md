# Описание алгоритма

## Ощее описание

На жестком диске хранится 2 файла:
1. Непосредственно сами данные (пары ключ-значение). Далее `storage.db`.
2. Таблица сдвигов (пары ключ-сдвиг в первом файле). Далее `index.db`.

Таблица сдвигов считывается в `HashMap` при создании экземпляра класса и переписывается при закрытии хранилища, если это необходимо 
(т.е. была добавлена/удалена/ищменена какая-то пара ключ-значение).

## Описание методов

1. `V read(K key)` Если в таблице сдвигов нет указанного ключа, то возвращается `null`. 
   Если же такой ключ присутствуюет в хранилище, то необходимое значение считывается из `storage.db` с помощью `RandomAccessFile`.
   Ассимптотика -- **O(1)**.
   
2. `boolean exists(K key)` Проверяется наличие ключа в таблице сдвигов.
   Ассимптотика -- **O(1)**.

3. `void write(K key, V value)` Пара ключ-значение записывается в конец `storage.db` с помощью `BufferedOutputStream`.
   Пара ключ-сдвиг записывается в таблицу сдвигов. При этом `flush()` вызывается только если возникла необходимость считать
   ещё реально не записанное (т.е. лежащее в кэше `BufferedOutputStream`-а значение).
   Ассимптотика -- **O(1)**.
   
4. `void delete(K key)` Ключ удаляется из таблицы сдвигов.
   Ассимптотика -- **O(1)**.
   
5. `Iterator<K> readKeys()` Возвращается сет ключей из таблицы сдвигов.
   Ассимптотика -- **O(1)**.

6. `int size()` Возвращается размер таблицы сдвигов.
   Ассимптотика -- **O(1)**.
   
7. `void close()` Устанавливается флаг, помечающий хранилище как закрытое.
   Если количество удалённых ключей в 4 раза больше количества ключей, которые в данный момент времени лежат в хранилище,
   то файл `storage.db` перезаписывается, при этом обновляются сдвиги для каждого ключа.
   Если необходимо перезаписывается таблица сдвигов.
   Ассимптотика -- **O(n)**. При этом реальное время работы может быть как **O(1)**, так и **O(n)**.
   Т.к. перезапись `storage.db` происходит только при удалении хотя бы *3/4* части ключей, то аммортизированно получаем **O(1)**.